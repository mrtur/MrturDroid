PhoneticArtsFile Config
Version 01

# -----------------------------------------------------------------------------
# HMM Configuration File for Run-time Stage of the Synthesis:
# -----------------------------------------------------------------------------
#
# Note: This is a customization that should be reasonably suitable for embedded
# devices. Major differences with the slower, better quality, version:
#
#    - No mcep post-filtering (formant emphasis filter) performed.
#    - Mcep stream GV weight is increased
#    - Number of GV steps is smaller
#
synthesis_method        "embedded_hmm" ;

#
# Speaking rate control (rho):
#
#    Range  : [-7.0, 7.0] (slower -> faster)
#    Default: 0.0
#
hmms.dur_factor         0.0;

#
# Multiply F0:
#
#     Range: [0.0, 5.0]
#   Default: 1.0
#
hmms.multiply_f0        1.0;

#
# Shift F0:
#
#     Range: [0.0, 100.0]
#   Default: 0.0
#
hmms.add_f0             0.0;

#
# Scale the F0 variance:
#
#     Range: any (as it doesn't work very well)
#   Default: 1.0
#
hmms.varscale_f0        1.0;

#
# Use fixed point LSP to LPC conversion. Default: true
#
hmms.fast_lsp2lpc true;

#
# Postfiltering (spectrum enhancement) tuning parameter:
#
#     Range: [0.0, 1.0]
#            1.0 --> no enhancement.
#            0.0 --> strong enhancemet.
#   Default: 0.6
#
hmms.postfilter_coef    0.60;

#
# Number of iterations of postfiltering:
#
#     Range: > 0
#   Default: 2
#
hmms.num_pf_iter        2;

#
# Voiced/unvoiced threshold:
#
#     Range: [0.0, 1.0]
#   Default: 0.5
#
hmms.uv_threshold 0.5;

#
# Duration in seconds (please double check!):
#
#     Range: [0.0, 30.0]
#   Default: 0.0
#
hmms.total_length_secs 0.0;

#
# Use state alignments (Default: false)
#
hmms.use_state_align false;

#
# Use phone alignments (Default: false)
#
hmms.use_phone_align false;

#
# Number of frame delays in the RLS parameter generation algorithm.
#
# Note: Minimal number is 1, as the number of frame delay increases,
#       the algorithm is more accurate but slow.
#
hmms.num_rls_delay_frame 15;

#
# Use Global Variance (Default: false)
#
hmms.use_gv false;

#
# Global Variance: Maximum number of steps (Default: 25)
#
# Note: Minimal number of steps is 0.
#
hmms.gv_max_steps 2;

#
# Global Variance: weight for the MCEP (Default: 0.2)
#
# Note: Minimal number is 0
#
hmms.mcep_gvweight 0.9;

#
# Global Variance: weight for the ME (Default: 0.7)
#
# Note: Minimal number is 0
#
hmms.me_gvweight 0.7;

#
# Global Variance: weight for the LF0 (Default: 0.7)
#
# Note: Minimal number is 0
#
hmms.lf0_gvweight 0.7;

#
# Global Variance: Step size (Default: 0.25)
#
# Can't be <= 0.
#
hmms.gv_step_size 0.25;

#
# Start and end silences: duration (Default: 200.0)
#
# if < 0, then the silences duration are estimated using the HMM model.
#
hmms.sils_duration 20.0;

#
# Save generated parameter tracks (Default: false)
#
# If switched on (1), this will generate the cepstral (or LSP) and F0 tracks as
# "p_mcp" and "p_f0" features on the utterance.
#
hmms.save_gen_params false;

#
# Don't use the vocoder (Default: false)
#
hmms.no_vocoder false;

#
# Verbose mode (Default: false)
#
# Currently disabled. In general, switching this on should trigger the generation of
# verbose synthesis information on the console.
#
hmms.verbose false;

#
# Type of excitation: "ap_server", "ap_embedded", "ap_embedded_pulses", "pulses"
#
hmms.excitation_type "ap_embedded";

#
# Use warped lattice filter instead of MLSA for mel-cepstral coefficients.
#
hmms.mcep_wlf false;

#
# Warped lattice filter order.
#
hmms.wlf_filter_order 40;

#
# Warped lattice filter conversion FFT order. Conversion size
# half of this number must be bigger than <wlf_filter_order>.
#
hmms.wlf_conversion_fft_order 128;

#
# Process silences:
#
hmms.process_silences true ;

#
# Scale the size of the output waveforms:
#
# A negative value invokes the dynamic range limiter to avoid clipping
#
output_gain 1.5;

#
# Invokes the dynamic range compressor to avoid clipping.
# Valid values: non, linear, adaptive
#  `non`: no compression, just clipping
#  `linear`: mild linear compression
#  `adaptive`: adaptive compression, more suitable for
#              higher values of output_gain (i.e. > 1.5)
#
dynamic_range_compression_type "adaptive";

#
# Low-shelf waveform domain equalizer:
#
# On embedded platforms we should always use it.
#
apply_low_shelf_equalizer true ;


#
# Engine sample rate (global, not related to HMM synthesis):
#
engine_sample_rate 22050 ;

#
# Prosody modification: f0 emphasis
#
prosmod.f0emph.stress.init 0.05 ;
prosmod.f0emph.stress.mid 0.2 ;
prosmod.f0emph.stress.final 0.05 ;

#
# Prosody modification: duration emphasis
#
prosmod.duremph.stress.init 0.05 ;
prosmod.duremph.stress.mid 0.2 ;
prosmod.duremph.stress.final 0.05 ;
